package com.example.alarmapp.ui.fragments

import android.app.AlarmManager
import android.content.Context
import android.os.Bundle
import android.view.*
import androidx.databinding.DataBindingUtil
import androidx.fragment.app.Fragment
import androidx.lifecycle.ViewModelProvider
import androidx.navigation.findNavController
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.example.alarmapp.R
import com.example.alarmapp.data.database.AlarmDatabase
import com.example.alarmapp.data.models.AlarmItem
import com.example.alarmapp.data.repository.AlarmRepository
import com.example.alarmapp.databinding.FragmentMainBinding
import com.example.alarmapp.ui.AlarmViewModelFactory
import com.example.alarmapp.ui.adapters.AlarmsListAdapter
import com.example.alarmapp.ui.interfaces.AlarmViewsOnClickListener
import com.example.alarmapp.ui.viewmodels.AlarmViewModel
import com.example.alarmapp.utils.AlarmHelper
import com.example.alarmapp.utils.DialogHelper
import com.example.alarmapp.utils.Messages


private const val TAG = "mainFragment"

class MainFragment : Fragment(), AlarmViewsOnClickListener {

    private lateinit var binding: FragmentMainBinding
    private lateinit var viewModel: AlarmViewModel
    private var alarmList = mutableListOf<AlarmItem>()
    private lateinit var alarmManager: AlarmManager
    private lateinit var adapter: AlarmsListAdapter
    private lateinit var rvMain: RecyclerView

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {

        // Inflate the layout for this fragment
        binding =
            DataBindingUtil.inflate(inflater, R.layout.fragment_main, container, false)

        // get a reference to the application context. we need application context to
        // create database instance
        val application = requireNotNull(this.activity).application
        // create database and get reference to Dao Object
        val dataDao = AlarmDatabase.getDatabaseInstance(application).alarmDao()
        // get reference to the repository class
        val repository = AlarmRepository(dataDao)
        //get instance of the viewModelFactory
        val viewModelFactory = AlarmViewModelFactory(repository)
        // initialize the ViewModel class
        viewModel = ViewModelProvider(this, viewModelFactory).get(AlarmViewModel::class.java)

        // initialize alarm manager
        alarmManager = context?.getSystemService(Context.ALARM_SERVICE) as AlarmManager

        // get reference to the adapter class
        adapter = AlarmsListAdapter(requireContext(), this)

        // init recycler view
        rvMain = binding.rvMainFragment
        // set layout for recyclerview
        rvMain.layoutManager = LinearLayoutManager(context)

        // set the recyclerview on main_fragment adapter to the adapter class
        rvMain.adapter = adapter


        // get and observe all alarms from view model
        viewModel.alarms().observe(viewLifecycleOwner, { listOfAlarms ->

            this.alarmList = listOfAlarms.toMutableList()
            // send the alarms list to the adapter by
            // using submitList method from ListAdapter class
            adapter.submitList(listOfAlarms)

            // if alarms list is empty
            if (listOfAlarms.isEmpty()) binding.tvNoAlarms.visibility = View.VISIBLE
            else binding.tvNoAlarms.visibility = View.GONE

        })

        // we get a reference of the button in FragmentMainBinding class which
        // auto generated by data binding library
        // when the user clicked this floating button, we navigate to the add new alarm fragment
        // by using navigation library action (action_mainFragment_to_setAlarmFragment)
        binding.fabAddNewAlarm.setOnClickListener { btn ->
            btn.findNavController().navigate(R.id.action_mainFragment_to_setAlarmFragment)
        }

        // fragment has option menu on actionbar
        setHasOptionsMenu(true)

        // returning the root element of the associated xml layout
        return binding.root
    }

    override fun onSwitchToggle(position: Int) {
        val alarmItem = alarmList[position]

        val alarmHelper = AlarmHelper(requireContext())

        // on switch button state change
        if (alarmItem.isScheduled) {
            // call the cancelAlarm method to cancel the alarm and
            // change the isScheduled value to false ...
            val updatedAlarm = alarmHelper.cancelAlarm(alarmItem)
            // update alarm item on database
            viewModel.updateAlarm(updatedAlarm)
            rvMain.post { adapter.notifyItemChanged(position) }

        } else {
            // call the scheduleAlarm method to schedule the alarm and
            // change the isScheduled value to true ...
            val updatedAlarm = alarmHelper.scheduleAlarm(alarmItem)
            // update alarm item on database
            viewModel.updateAlarm(updatedAlarm)
            // to refresh this recyclerview item, we need to call notifyItemChanged(position)
            // on UI thread to avoid:
            // (IllegalStateException: Cannot call this method while
            // RecyclerView is computing a layout or scrolling).
            // here by using post method from View class, we are adding
            // the runnable block (adapter.notifyItemChanged(position)),
            // to the View (RecyclerView) message queue, and run it on user interface (UI)
            rvMain.post { adapter.notifyItemChanged(position) }

        }
    }

    // for recyclerview item popup menu options
    override fun onOptionsMenuItemClicked(position: Int, menuItem: MenuItem) {
        val alarmItem = alarmList[position]

        val alarmHelper = AlarmHelper(requireContext())

        when (menuItem.itemId) {
            R.id.delete_alarm -> {
                // cancel alarm if scheduled
                if (alarmItem.isScheduled) alarmHelper.cancelAlarm(alarmItem)
                // delete the alarm item from database
                viewModel.deleteAlarm(alarmItem)
            }
            R.id.edit_alarm -> {
                findNavController().navigate(
                    MainFragmentDirections.actionMainFragmentToSetAlarmFragment(
                        alarmList[position]
                    )
                )
            }
        }
    }

    // create fragment action bar menu, in order this to work we need to call,
    // setHasOptionsMenu(true) on fragment onCreateView()
    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        super.onCreateOptionsMenu(menu, inflater)
        inflater.inflate(R.menu.action_bar_menu, menu)
    }

    // if the user selected on of the action bar menu items
    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.delete_all_alarm -> {
                // ask user for confirmation by using
                // AlertDialog to show popup message
                // before deleting the alarms we will through all alarms
                // and check if of them is already scheduled. if yes then cancel it
                if (alarmList.isNotEmpty()) {
                    DialogHelper.showDialog(
                        requireContext(),
                        object : DialogHelper.DialogInterface {
                            override fun getRespond(respond: Int) {
                                if (respond == 1) {
                                    val alarmHelper = AlarmHelper(requireContext())
                                    alarmList.forEach {
                                        if (it.isScheduled) alarmHelper.cancelAlarm(it)
                                    }
                                    // if yes clicked delete alarm item
                                    viewModel.deleteAllAlarms()
                                }
                            }
                        })
                } else {
                    Messages.showSnack(binding.root, "List is empty")
                }
            }
        }
        return super.onOptionsItemSelected(item)
    }
}